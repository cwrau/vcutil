#!/usr/bin/env python
# apt-find-foreign (part of ossobv/vcutil) // wdoekes/2018,2022 //
#   Public Domain
"""
Script to find Debian/Ubuntu packages from "foreign" archives.

Outputs a list of apt source lists where the currently installed
packages come from. For lists that have fewer than 100 items, it also
lists the package names.

Usage example:

    apt-find-foreign

Output example:

    Lists with corresponding package counts:
      269     (local only)
      1       (updates available)
      3075    http://ubuntuserver.com/ubuntu
      2       http://custom-ppa.com/ubuntu

    Lists with very few packages (or with remarks):
      (local only)
        - libswresample-ffmpeg1
        - libquvi-scripts
        - qml-module-ubuntu-performancemetrics
        ...
      (updates available)
        - gpg
      http://custom-ppa.com/ubuntu
        - packagex
        - packagey

Because apt-cache policy has to do a lot of work, it takes more than 2 seconds
to run on my desktop.
"""
from collections import OrderedDict, defaultdict
from subprocess import check_output
from tempfile import TemporaryFile

MAX_DISPLAY = 100


class VersionState(object):
    def __init__(self, version, list_urls, latest_version=None):
        self.version = version
        self.list_urls = tuple(sorted(list_urls))
        self.has_newer = (latest_version and latest_version != version)
        self.latest_version = latest_version or version


class Package(object):
    def __init__(self, name, state, policy=None):
        self.name = name
        self.state = state
        # By injecting the policy, we save huge amounts of time. Doing one
        # fork()/exec() per package would be horrendously slow.
        self.policy = policy

    def get_policy(self):
        """
        Return apt-cache policy PKG_NAME output.

        For example::

            vcutil:
              Installed: 1.11
              Candidate: 1.11
              Version table:
             *** 1.11 500
                  500 http://example.com/ubuntu bionic/osso amd64 Packages
                  500 http://example.com/ubuntu bionic/osso i386 Packages
                  100 /var/lib/dpkg/status
               1.10 500
                  500 http://example.com/ubuntu bionic/osso amd64 Packages
                  500 http://example.com/ubuntu bionic/osso i386 Packages
        """
        if self.policy is None:
            out = check_output(['apt-cache', 'policy', self.name])
            out = out.decode('utf-8')
            self.policy = out
        return self.policy

    def get_state(self):
        """
        Return dpkg source version state from the policy.

        For example::

            VersionState('1.2.3', ('http://example.com/ubuntu',), '1.2.4')
        """
        if not hasattr(self, '_state'):
            self._state = self._extract_source_urls(
                self.name, self.state, self.get_policy())
        return self._state

    @staticmethod
    def _extract_source_urls(name, state, policy):
        out = policy.split('\n')
        outiter = iter(out)
        for line in outiter:
            if line.startswith('  Version table:'):
                break

        latest = None
        current = None

        current_version_prio = next(outiter).split()
        while True:
            urls = set()

            # ' *** 1.11 500'
            if len(current_version_prio) == 3:
                current, version, prio = current_version_prio
                assert current == '***', current_version_prio
                current = version
            elif len(current_version_prio) == 2:
                version, prio = current_version_prio
                current = False
            else:
                assert False, current_version_prio

            if latest is None:
                latest = version

            # '      500 http://example.com/ubuntu bionic/osso amd64 Packages'
            # '      100 /var/lib/dpkg/status'
            for line in outiter:
                if not line.startswith(' ' * 8):
                    break
                urls.add(line.split()[1])
            else:
                assert current or state == 'rc', (name, state, urls)
                break  # at EOF

            # This was with '***'. We're done here.
            if current:
                break

            # Restart loop with the next (older) version.
            current_version_prio = line.split()

        assert current is not None, (name, state, current)
        urls.remove('/var/lib/dpkg/status')
        return VersionState(current, list_urls=urls, latest_version=latest)

    def __repr__(self):
        return self.name


def dpkg_l():
    """
    Return list of [(package_name, state), ...].
    """
    out = check_output(['dpkg', '-l'])
    out = out.decode('utf-8')
    out = out.split('\n')[1:]
    out = [i for i in out if i and not i.startswith(tuple('|+'))]
    out = [list(reversed(i.split()))[-2:] for i in out]  # only "name", "ii"
    out = [(i[0].split(':', 1)[0], i[1]) for i in out]   # drop ":amd64"
    return out


def apt_cache_policy(package_names):
    """
    Return apt_cache_policy dict, one string per package.
    """
    with TemporaryFile(mode='w+b') as fp:
        fp.write('\0'.join(package_names).encode('utf-8'))
        fp.seek(0)
        out = check_output(['xargs', '-0', 'apt-cache', 'policy'], stdin=fp)
    out = out.decode('utf-8').strip()
    out = out.split('\n')
    buf = []
    for line in out:
        if not line.startswith(' '):
            if buf:
                blob = '\n'.join(buf)
                name = blob.split(':', 1)[0]
                yield (name, blob)
                buf = []
        buf.append(line)
    if buf:
        blob = '\n'.join(buf)
        name = blob.split(':', 1)[0]
        yield (name, blob)


packages = OrderedDict(dpkg_l())
policies = dict(apt_cache_policy(packages.keys()))
lists = defaultdict(list)

for pkg_name in packages.keys():
    p = Package(pkg_name, state=packages[pkg_name], policy=policies[pkg_name])
    state = p.get_state()

    if p.state not in ('ii', 'hi'):
        assert p.state == 'rc', (p.name, p.state)
        lists['(rc only)'].append(p)
    elif state.list_urls:
        # May still have newer, but we don't care..
        for list_ in state.list_urls:
            lists[list_].append(p)
    elif state.has_newer:
        lists['(updates available)'].append(p)
    else:
        lists['(local only)'].append(p)


print('Lists with corresponding package counts:')
min_count = len(packages)
for key in sorted(lists.keys()):
    print('  {}\t{}'.format(len(lists[key]), key))
    min_count = min(len(lists[key]), min_count)

if min_count <= MAX_DISPLAY or any(
        key.startswith('(') for key in lists.keys()):
    print('')
    print('Lists with very few packages (or with remarks):')
    for key in sorted(lists.keys()):
        if len(lists[key]) <= MAX_DISPLAY or key.startswith('('):
            print('  {}'.format(key))
            for package in lists[key]:
                print('    - {}'.format(package.name))
